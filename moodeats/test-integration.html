<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MoodEats Integration Tests</title>
    <style>
        body { font-family: monospace; padding: 20px; background: #1a1a1a; color: #0f0; }
        .test-pass { color: #0f0; }
        .test-fail { color: #f00; font-weight: bold; }
        .test-section { margin: 20px 0; padding: 10px; border: 1px solid #333; }
        #test-frame { width: 100%; height: 400px; border: 2px solid #666; margin: 20px 0; }
        .summary { margin-top: 20px; padding: 15px; border: 2px solid #fff; }
    </style>
</head>
<body>
    <h1>MoodEats Integration Test Suite</h1>
    <p>Testing UI interactions, timing, and user flows...</p>

    <iframe id="test-frame" src="moodeats-planner.html"></iframe>

    <div id="results"></div>
    <div id="summary" class="summary"></div>

    <script>
        let testResults = [];
        let iframe, iframeDoc, iframeWin;

        // Test runner
        async function test(name, testFn) {
            try {
                await testFn();
                testResults.push({ name, passed: true });
                logResult(`✓ ${name}`, true);
                return true;
            } catch (error) {
                testResults.push({ name, passed: false, error: error.message });
                logResult(`✗ ${name}: ${error.message}`, false);
                return false;
            }
        }

        function logResult(message, passed) {
            const div = document.createElement('div');
            div.className = passed ? 'test-pass' : 'test-fail';
            div.textContent = message;
            document.getElementById('results').appendChild(div);
        }

        // Assert helper
        function assert(condition, message) {
            if (!condition) {
                throw new Error(message || 'Assertion failed');
            }
        }

        // Wait helper
        function wait(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        // Wait for element
        async function waitForElement(selector, timeout = 5000) {
            const start = Date.now();
            while (Date.now() - start < timeout) {
                const element = iframeDoc.querySelector(selector);
                if (element) return element;
                await wait(100);
            }
            throw new Error(`Element ${selector} not found after ${timeout}ms`);
        }

        // Simulate click
        function simulateClick(element) {
            const event = new MouseEvent('click', {
                view: iframeWin,
                bubbles: true,
                cancelable: true
            });
            element.dispatchEvent(event);
        }

        // Run all tests
        async function runTests() {
            // Wait for iframe to load
            iframe = document.getElementById('test-frame');
            await new Promise(resolve => {
                iframe.onload = resolve;
                if (iframe.contentDocument.readyState === 'complete') {
                    resolve();
                }
            });

            iframeDoc = iframe.contentDocument;
            iframeWin = iframe.contentWindow;

            // Wait for app initialization
            await wait(1000);

            logResult('\n=== CRITICAL TIMING TESTS ===', true);

            // Test 1: Meals are loaded before UI interaction
            await test('meals array is populated on load', () => {
                assert(iframeWin.meals, 'meals variable should exist');
                assert(Array.isArray(iframeWin.meals), 'meals should be an array');
                assert(iframeWin.meals.length === 76, `Expected 76 meals, got ${iframeWin.meals.length}`);
            });

            // Test 2: Event listeners are attached
            await test('mood buttons have event listeners', async () => {
                const freshBtn = iframeDoc.querySelector('[data-mood="fresh"]');
                assert(freshBtn, 'Fresh button should exist');

                // Check if clicking triggers UI change
                const initialClasses = freshBtn.className;
                simulateClick(freshBtn);
                await wait(100);

                assert(freshBtn.classList.contains('btn-primary'), 'Button should have btn-primary class after click');
            });

            logResult('\n=== UI INTERACTION TESTS ===', true);

            // Test 3: Fresh mood shows meals
            await test('clicking Fresh shows fresh meals', async () => {
                const freshBtn = iframeDoc.querySelector('[data-mood="fresh"]');
                simulateClick(freshBtn);
                await wait(200);

                const suggestionsArea = iframeDoc.querySelector('#suggestionsArea');
                assert(!suggestionsArea.classList.contains('hidden'), 'Suggestions area should be visible');

                const mealCards = iframeDoc.querySelectorAll('#mealSuggestions .card');
                assert(mealCards.length > 0, `Should show meals, but found ${mealCards.length}`);

                // Verify these are actually fresh meals
                const freshMeals = iframeWin.meals.filter(m => m.moods.includes('fresh'));
                assert(mealCards.length <= freshMeals.length, 'Should not show more meals than exist');
            });

            // Test 4: Each mood button works
            const moods = ['cozy', 'hearty', 'quick', 'breakfast', 'seafood', 'asian', 'italian'];
            for (const mood of moods) {
                await test(`${mood} mood button shows meals`, async () => {
                    const btn = iframeDoc.querySelector(`[data-mood="${mood}"]`);
                    assert(btn, `${mood} button should exist`);

                    simulateClick(btn);
                    await wait(200);

                    const mealCards = iframeDoc.querySelectorAll('#mealSuggestions .card');
                    const expectedMeals = iframeWin.meals.filter(m => m.moods.includes(mood));
                    assert(mealCards.length > 0 || expectedMeals.length === 0,
                           `${mood} should show meals if they exist (found ${mealCards.length}/${expectedMeals.length})`);
                });
            }

            logResult('\n=== TAB SWITCHING TESTS ===', true);

            // Test 5: Tab switching works
            await test('can switch between Browse and Plan tabs', async () => {
                const planTab = iframeDoc.querySelector('#planTab');
                const browseTab = iframeDoc.querySelector('#browseTab');

                // Switch to Plan
                simulateClick(planTab);
                await wait(100);
                assert(planTab.classList.contains('tab-active'), 'Plan tab should be active');
                assert(!iframeDoc.querySelector('#planView').classList.contains('hidden'), 'Plan view should be visible');

                // Switch back to Browse
                simulateClick(browseTab);
                await wait(100);
                assert(browseTab.classList.contains('tab-active'), 'Browse tab should be active');
                assert(!iframeDoc.querySelector('#browseView').classList.contains('hidden'), 'Browse view should be visible');
            });

            logResult('\n=== MEAL SELECTION TESTS ===', true);

            // Test 6: Meal selection modal opens
            await test('clicking Select opens meal modal', async () => {
                // Switch to Plan tab
                simulateClick(iframeDoc.querySelector('#planTab'));
                await wait(100);

                // Click select breakfast
                const selectBtn = iframeDoc.querySelector('[onclick*="selectMealForSlot(\'breakfast\')"]');
                assert(selectBtn, 'Select breakfast button should exist');

                // Trigger the onclick directly since simulateClick might not work with onclick
                iframeWin.selectMealForSlot('breakfast');
                await wait(200);

                const modal = iframeDoc.querySelector('#mealModal');
                assert(modal && modal.open, 'Modal should be open');

                const modalMeals = iframeDoc.querySelectorAll('#modalMeals .card');
                assert(modalMeals.length > 0, `Modal should show meals (found ${modalMeals.length})`);
            });

            // Test 7: Modal filters work
            await test('modal category filters work', async () => {
                // Ensure modal is open for breakfast
                iframeWin.selectMealForSlot('breakfast');
                await wait(200);

                const cozyFilter = iframeDoc.querySelector('.modal-filter[data-filter="cozy"]');
                if (cozyFilter) {
                    const beforeCount = iframeDoc.querySelectorAll('#modalMeals .card').length;
                    simulateClick(cozyFilter);
                    await wait(200);

                    const afterCount = iframeDoc.querySelectorAll('#modalMeals .card').length;
                    assert(afterCount >= 0, 'Filter should not break the display');
                }
            });

            logResult('\n=== SEARCH FUNCTIONALITY TESTS ===', true);

            // Test 8: Search works
            await test('search input filters meals', async () => {
                // Switch to Browse
                simulateClick(iframeDoc.querySelector('#browseTab'));
                await wait(100);

                const searchInput = iframeDoc.querySelector('#searchInput');
                assert(searchInput, 'Search input should exist');

                // Type in search
                searchInput.value = 'chicken';
                searchInput.dispatchEvent(new Event('input', { bubbles: true }));
                await wait(300);

                const suggestionsArea = iframeDoc.querySelector('#suggestionsArea');
                if (!suggestionsArea.classList.contains('hidden')) {
                    const mealCards = iframeDoc.querySelectorAll('#mealSuggestions .card');
                    assert(mealCards.length > 0, 'Should show chicken meals');
                }
            });

            // Test 9: Empty search handling
            await test('empty search clears results properly', async () => {
                const searchInput = iframeDoc.querySelector('#searchInput');
                searchInput.value = '';
                searchInput.dispatchEvent(new Event('input', { bubbles: true }));
                await wait(200);

                // Should either hide suggestions or show initial state
                assert(true, 'Empty search handled without errors');
            });

            logResult('\n=== EDGE CASES & ERROR HANDLING ===', true);

            // Test 10: Rapid clicking doesn't break UI
            await test('rapid button clicking is handled gracefully', async () => {
                const btns = iframeDoc.querySelectorAll('.mood-btn');
                for (let i = 0; i < 10; i++) {
                    simulateClick(btns[i % btns.length]);
                }
                await wait(500);

                // Check UI is still functional
                const activeBtn = iframeDoc.querySelector('.mood-btn.btn-primary');
                assert(activeBtn, 'Should have exactly one active button after rapid clicks');
            });

            // Test 11: Special characters in search
            await test('special characters in search don\'t break app', async () => {
                const searchInput = iframeDoc.querySelector('#searchInput');
                const specialStrings = ['<script>', '"; DROP TABLE;', '\\n\\r', '🍕🍔🌮'];

                for (const str of specialStrings) {
                    searchInput.value = str;
                    searchInput.dispatchEvent(new Event('input', { bubbles: true }));
                    await wait(100);
                }

                assert(true, 'Special characters handled safely');
            });

            logResult('\n=== DATA INTEGRITY TESTS ===', true);

            // Test 12: All meals have required fields in UI
            await test('all displayed meals show proper nutrition info', async () => {
                const freshBtn = iframeDoc.querySelector('[data-mood="fresh"]');
                simulateClick(freshBtn);
                await wait(200);

                const mealCards = iframeDoc.querySelectorAll('#mealSuggestions .card');
                mealCards.forEach(card => {
                    const text = card.textContent;
                    assert(text.includes('g protein'), 'Should show protein');
                    assert(text.includes('g carbs'), 'Should show carbs');
                });
            });

            // Test 13: Breakfast/non-breakfast filtering
            await test('breakfast slot only shows breakfast meals', async () => {
                iframeWin.selectMealForSlot('breakfast');
                await wait(200);

                const modalTitle = iframeDoc.querySelector('#modalTitle');
                assert(modalTitle.textContent.includes('Breakfast'), 'Modal title should say Breakfast');

                // Check that all meals shown are breakfast meals
                const breakfastMeals = iframeWin.meals.filter(m => m.moods.includes('breakfast'));
                const modalMealCount = iframeDoc.querySelectorAll('#modalMeals .card').length;
                assert(modalMealCount <= breakfastMeals.length, 'Should only show breakfast meals');
            });

            // Test 14: Lunch/Dinner don't show breakfast
            await test('lunch slot excludes breakfast meals', async () => {
                iframeWin.selectMealForSlot('lunch');
                await wait(200);

                // Verify no breakfast-only meals appear
                const modalTitle = iframeDoc.querySelector('#modalTitle');
                assert(modalTitle.textContent.includes('Lunch'), 'Modal title should say Lunch');
                assert(true, 'Lunch filtering applied');
            });

            logResult('\n=== PERFORMANCE TESTS ===', true);

            // Test 15: Load time is reasonable
            await test('meals load within 2 seconds', () => {
                assert(iframeWin.meals && iframeWin.meals.length > 0, 'Meals should be loaded');
                assert(true, 'Performance acceptable');
            });

            // Display summary
            displaySummary();
        }

        function displaySummary() {
            const passed = testResults.filter(r => r.passed).length;
            const failed = testResults.filter(r => !r.passed).length;
            const total = testResults.length;

            const summaryDiv = document.getElementById('summary');
            summaryDiv.innerHTML = `
                <h2>Test Summary</h2>
                <div>Total: ${total}</div>
                <div class="test-pass">Passed: ${passed}</div>
                <div class="test-fail">Failed: ${failed}</div>
                <div>Success Rate: ${Math.round((passed/total) * 100)}%</div>
                ${failed === 0 ? '<div class="test-pass"><br/>🎉 ALL INTEGRATION TESTS PASSED!</div>' :
                                  '<div class="test-fail"><br/>⚠️ SOME TESTS FAILED - Check UI interactions!</div>'}
            `;

            // Log failures for debugging
            if (failed > 0) {
                console.error('Failed tests:', testResults.filter(r => !r.passed));
            }
        }

        // Run tests on load
        window.addEventListener('load', () => {
            setTimeout(runTests, 1000);
        });
    </script>
</body>
</html>